from flask import Flask, request, jsonify
import mysql.connector
from dotenv import load_dotenv
import os
from flask_cors import CORS
import json
from uuid import uuid4 # Using uuid for potential future ID generation

load_dotenv()

app = Flask(__name__)
CORS(app) # Enable CORS for all origins

# Database connection configuration (single database)
db_config = {
    "host": os.getenv("DB_HOST"),
    "port": int(os.getenv("DB_PORT")),
    "user": os.getenv("DB_USER"),
    "password": os.getenv("DB_PASSWORD"),
    "database": os.getenv("DB_NAME")
}

def get_db_connection():
    """Establishes and returns a database connection."""
    try:
        connection = mysql.connector.connect(**db_config)
        return connection
    except mysql.connector.Error as err:
        print(f"Error connecting to database: {err}")
        return None

# --- Candidate Endpoints ---

@app.route('/api/candidates', methods=['GET'])
def get_candidates():
    """Fetches all candidates from the mail_candidate table (for this app)."""
    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor(dictionary=True)
    try:
        # Fetch only from the new mail_candidate table
        cursor.execute("SELECT * FROM mail_candidate")
        candidates = cursor.fetchall()

        # Convert skills string back to a list
        for candidate in candidates:
            if candidate.get('skills'):
                candidate['skills'] = candidate['skills'].split(',')
            else:
                candidate['skills'] = []
            # Ensure ID is string for frontend consistency
            candidate['id'] = str(candidate['id'])

        return jsonify(candidates)
    except mysql.connector.Error as err:
        print(f"Error fetching candidates from mail_candidate: {err}")
        return jsonify({"error": "Failed to fetch candidates from mail_candidate"}), 500
    finally:
        cursor.close()
        conn.close()

@app.route('/api/candidates/<string:candidate_id>', methods=['GET'])
def get_candidate(candidate_id):
    """Fetches a single candidate by ID from the mail_candidate table."""
    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor(dictionary=True)
    try:
        # Fetch only from the new mail_candidate table
        cursor.execute("SELECT * FROM mail_candidate WHERE id = %s", (candidate_id,))
        candidate = cursor.fetchone()

        if candidate:
             if candidate.get('skills'):
                 candidate['skills'] = candidate['skills'].split(',')
             else:
                 candidate['skills'] = []
             candidate['id'] = str(candidate['id'])
             return jsonify(candidate)
        else:
            return jsonify({"error": "Candidate not found in mail_candidate"}), 404
    except mysql.connector.Error as err:
        print(f"Error fetching candidate from mail_candidate: {err}")
        return jsonify({"error": "Failed to fetch candidate from mail_candidate"}), 500
    finally:
        cursor.close()
        conn.close()


@app.route('/api/candidates', methods=['POST'])
def add_candidate():
    """Adds a new candidate to BOTH 'candidates' and 'mail_candidate' tables."""
    new_candidate_data = request.json
    if not new_candidate_data:
        return jsonify({"error": "Invalid request payload"}), 400

    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor()

    # Prepare data for insertion (assuming same relevant columns for both tables)
    skills_str = ",".join(new_candidate_data.get('skills', []))
    values = (
        new_candidate_data.get('name'),
        new_candidate_data.get('phoneNumber'),
        new_candidate_data.get('email'),
        new_candidate_data.get('resumeLink'),
        new_candidate_data.get('currentCompany'),
        new_candidate_data.get('experience'),
        skills_str,
        new_candidate_data.get('expectedSalary'),
        new_candidate_data.get('location'),
        new_candidate_data.get('notes')
        # Add other fields if your tables have more columns
    )

    sql_insert_candidates = """
    INSERT INTO candidates (name, phoneNumber, email, resumeLink, currentCompany, experience, skills, expectedSalary, location, notes)
    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
    """

    sql_insert_mail_candidate = """
    INSERT INTO mail_candidate (name, phoneNumber, email, resumeLink, currentCompany, experience, skills, expectedSalary, location, notes)
    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
    """

    inserted_mail_candidate = None
    try:
        # Use a transaction to ensure both inserts succeed or fail together
        conn.start_transaction()

        # Insert into the existing 'candidates' table
        cursor.execute(sql_insert_candidates, values)
        existing_db_candidate_id = cursor.lastrowid # Get ID from the existing table

        # Insert into the new 'mail_candidate' table
        cursor.execute(sql_insert_mail_candidate, values)
        mail_candidate_id = cursor.lastrowid # Get the ID from the mail_candidate table

        # If both inserts were successful, commit the transaction
        conn.commit()

        # Fetch the inserted candidate from the mail_candidate table to return
        cursor.execute("SELECT * FROM mail_candidate WHERE id = %s", (mail_candidate_id,))
        inserted_mail_candidate = cursor.fetchone()

        if not isinstance(inserted_mail_candidate, dict) and inserted_mail_candidate is not None:
             column_names = [desc[0] for desc in cursor.description]
             inserted_mail_candidate = dict(zip(column_names, inserted_mail_candidate))

        if inserted_mail_candidate:
             if inserted_mail_candidate.get('skills'):
                 inserted_mail_candidate['skills'] = inserted_mail_candidate['skills'].split(',')
             else:
                 inserted_mail_candidate['skills'] = []
             inserted_mail_candidate['id'] = str(inserted_mail_candidate['id']) # Ensure ID is string

        return jsonify(inserted_mail_candidate), 201 # Return the newly created candidate from mail_candidate

    except mysql.connector.Error as err:
        print(f"Error adding candidate to tables: {err}")
        conn.rollback() # Rollback the transaction if an error occurs
        return jsonify({"error": "Failed to add candidate to tables", "details": str(err)}), 500
    except Exception as e:
         print(f"An unexpected error occurred during candidate addition: {e}")
         conn.rollback()
         return jsonify({"error": "An unexpected error occurred during candidate addition", "details": str(e)}), 500
    finally:
        cursor.close()
        conn.close()


@app.route('/api/candidates/<string:candidate_id>', methods=['PUT'])
def update_candidate(candidate_id):
    """Updates an existing candidate in BOTH 'candidates' and 'mail_candidate' tables."""
    updates = request.json
    if not updates:
        return jsonify({"error": "Invalid request payload"}), 400

    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor()

    # Build update query dynamically based on provided fields
    update_fields = []
    update_values = []
    allowed_fields = [
        'name', 'phoneNumber', 'email', 'resumeLink', 'currentCompany',
        'experience', 'skills', 'expectedSalary', 'location', 'notes'
    ] # Define allowed fields to prevent arbitrary updates

    for field, value in updates.items():
        if field in allowed_fields:
            if field == 'skills' and isinstance(value, list):
                update_fields.append(f"{field} = %s")
                update_values.append(",".join(value))
            else:
                update_fields.append(f"{field} = %s")
                update_values.append(value)

    if not update_fields:
        # Fetch the candidate from mail_candidate to return even if no fields updated
        cursor.execute("SELECT * FROM mail_candidate WHERE id = %s", (candidate_id,))
        updated_candidate = cursor.fetchone()
        if not isinstance(updated_candidate, dict) and updated_candidate is not None:
            column_names = [desc[0] for desc in cursor.description]
            updated_candidate = dict(zip(column_names, updated_candidate))

        if updated_candidate:
            if updated_candidate.get('skills'):
                updated_candidate['skills'] = updated_candidate['skills'].split(',')
            else:
                updated_candidate['skills'] = []
            updated_candidate['id'] = str(updated_candidate['id'])

        return jsonify(updated_candidate), 200 # Return the candidate from mail_candidate

    sql_update = f"UPDATE candidates SET {', '.join(update_fields)} WHERE id = %s"
    sql_update_mail = f"UPDATE mail_candidate SET {', '.join(update_fields)} WHERE id = %s"
    update_values_with_id = update_values + [candidate_id]

    updated_mail_candidate = None
    try:
        # Use a transaction
        conn.start_transaction()

        # Update the existing 'candidates' table
        cursor.execute(sql_update, update_values_with_id)
        rows_updated_existing = cursor.rowcount # Check if update affected any rows

        # Update the new 'mail_candidate' table
        cursor.execute(sql_update_mail, update_values_with_id)
        rows_updated_mail = cursor.rowcount # Check if update affected any rows

        # If both updates were successful (or if the row didn't exist in one), commit
        conn.commit()

        if rows_updated_mail == 0:
            # If the candidate wasn't found in mail_candidate, it wasn't added by this app
            conn.rollback() # Rollback the transaction
            return jsonify({"error": "Candidate not found in mail_candidate"}), 404

        # Fetch the updated candidate from mail_candidate to return
        cursor.execute("SELECT * FROM mail_candidate WHERE id = %s", (candidate_id,))
        updated_mail_candidate = cursor.fetchone()

        if not isinstance(updated_mail_candidate, dict) and updated_mail_candidate is not None:
              column_names = [desc[0] for desc in cursor.description]
              updated_mail_candidate = dict(zip(column_names, updated_mail_candidate))

        if updated_mail_candidate:
             if updated_mail_candidate.get('skills'):
                 updated_mail_candidate['skills'] = updated_mail_candidate['skills'].split(',')
             else:
                 updated_mail_candidate['skills'] = []
             updated_mail_candidate['id'] = str(updated_mail_candidate['id'])

        return jsonify(updated_mail_candidate) # Return the updated candidate from mail_candidate

    except mysql.connector.Error as err:
        print(f"Error updating candidate in tables: {err}")
        conn.rollback()
        return jsonify({"error": "Failed to update candidate in tables", "details": str(err)}), 500
    except Exception as e:
        print(f"An unexpected error occurred during candidate update: {e}")
        conn.rollback()
        return jsonify({"error": "An unexpected error occurred during candidate update", "details": str(e)}), 500
    finally:
        cursor.close()
        conn.close()


@app.route('/api/candidates/<string:candidate_id>', methods=['DELETE'])
def delete_candidate(candidate_id):
    """Deletes a candidate from BOTH 'candidates' and 'mail_candidate' tables."""
    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor()
    sql_delete_candidates = "DELETE FROM candidates WHERE id = %s"
    sql_delete_mail_candidate = "DELETE FROM mail_candidate WHERE id = %s"

    try:
        # Use a transaction
        conn.start_transaction()

        # Delete from the existing 'candidates' table
        cursor.execute(sql_delete_candidates, (candidate_id,))
        rows_deleted_existing = cursor.rowcount

        # Delete from the new 'mail_candidate' table
        cursor.execute(sql_delete_mail_candidate, (candidate_id,))
        rows_deleted_mail = cursor.rowcount

        # If deletion in mail_candidate was successful, commit
        # (Assuming deletion in mail_candidate is the primary check for this app)
        conn.commit()

        if rows_deleted_mail == 0:
             # Candidate not found in the mail_candidate table
             conn.rollback() # Rollback if not found in the app's primary table
             return jsonify({"error": "Candidate not found in mail_candidate"}), 404
        # Note: If the candidate exists in mail_candidate but not existing, it will still return 200.


        return jsonify({"message": "Candidate deleted successfully from both tables"}), 200

    except mysql.connector.Error as err:
        print(f"Error deleting candidate from tables: {err}")
        conn.rollback()
        return jsonify({"error": "Failed to delete candidate from tables", "details": str(err)}), 500
    except Exception as e:
        print(f"An unexpected error occurred during candidate deletion: {e}")
        conn.rollback()
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

# --- Recipient Selection Endpoints ---
# These endpoints interact ONLY with the new 'recipient_data' table.

@app.route('/api/selections/<string:candidate_id>', methods=['GET'])
def get_recipient_selections(candidate_id):
    """Fetches recipient selections for a specific candidate from the recipient_data table."""
    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor(dictionary=True)
    try:
        # Fetch from the new recipient_data table
        sql = "SELECT * FROM recipient_data WHERE mailCandidateId = %s"
        cursor.execute(sql, (candidate_id,))
        selections_list = cursor.fetchall()

        if not selections_list:
             return jsonify({"error": "Selections not found for this candidate"}), 404

        selection_data = selections_list[0]

        if selection_data.get('fieldVisibility') and isinstance(selection_data['fieldVisibility'], str):
             selection_data['fieldVisibility'] = json.loads(selection_data['fieldVisibility'])

        formatted_selections = {
            "candidateId": str(selection_data['mailCandidateId']),
            "fieldVisibility": selection_data.get('fieldVisibility', {})
        }

        return jsonify(formatted_selections)

    except mysql.connector.Error as err:
        print(f"Error fetching recipient selections: {err}")
        return jsonify({"error": "Failed to fetch recipient selections", "details": str(err)}), 500
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500
    finally:
        cursor.close()
        conn.close()


@app.route('/api/selections/<string:candidate_id>', methods=['PUT'])
def update_or_create_recipient_selections(candidate_id):
    """Updates or creates recipient selections for a candidate in the recipient_data table."""
    selection_data = request.json
    if not selection_data or 'fieldVisibility' not in selection_data:
        return jsonify({"error": "Invalid request payload"}), 400

    conn = get_db_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    cursor = conn.cursor()
    try:
        # Check if selections already exist for this candidate in recipient_data
        cursor.execute("SELECT id FROM recipient_data WHERE mailCandidateId = %s", (candidate_id,))
        existing_selection = cursor.fetchone()

        field_visibility_json = json.dumps(selection_data['fieldVisibility'])

        if existing_selection:
            # Update existing selections
            sql = "UPDATE recipient_data SET fieldVisibility = %s WHERE mailCandidateId = %s"
            values = (field_visibility_json, candidate_id)
            cursor.execute(sql, values)
            conn.commit()
            message = "Selections updated successfully"
        else:
            # Create new selections
            sql = "INSERT INTO recipient_data (mailCandidateId, fieldVisibility) VALUES (%s, %s)"
            values = (candidate_id, field_visibility_json)
            cursor.execute(sql, values)
            conn.commit()
            message = "Selections created successfully"

        # Fetch the saved selections to return
        cursor.execute("SELECT * FROM recipient_data WHERE mailCandidateId = %s", (candidate_id,))
        saved_selection = cursor.fetchone()

        if not isinstance(saved_selection, dict) and saved_selection is not None:
              column_names = [desc[0] for desc in cursor.description]
              saved_selection = dict(zip(column_names, saved_selection))

        if saved_selection:
            if saved_selection.get('fieldVisibility') and isinstance(saved_selection['fieldVisibility'], str):
                 saved_selection['fieldVisibility'] = json.loads(saved_selection['fieldVisibility'])

            formatted_saved_selection = {
                 "candidateId": str(saved_selection['mailCandidateId']),
                 "fieldVisibility": saved_selection.get('fieldVisibility', {})
             }
            return jsonify(formatted_saved_selection), 200 if existing_selection else 201

        return jsonify({"message": message}), 200


    except mysql.connector.Error as err:
        print(f"Error updating/creating recipient selections: {err}")
        conn.rollback()
        return jsonify({"error": "Failed to update/create recipient selections", "details": str(err)}), 500
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        conn.rollback()
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500
    finally:
        cursor.close()
        conn.close()


# Delete endpoint for selections (optional, depending on your needs)
# @app.route('/api/selections/<string:candidate_id>', methods=['DELETE'])
# def delete_recipient_selections(candidate_id):
#     """Deletes recipient selections for a candidate from the recipient_data table."""
#     conn = get_db_connection()
#     if conn is None:
#         return jsonify({"error": "Database connection failed"}), 500

#     cursor = conn.cursor()
#     try:
#         sql = "DELETE FROM recipient_data WHERE mailCandidateId = %s"
#         cursor.execute(sql, (candidate_id,))
#         conn.commit()

#         if cursor.rowcount == 0:
#             return jsonify({"error": "Selections not found for this candidate"}), 404
#         else:
#             return jsonify({"message": "Selections deleted successfully"}), 200

#     except mysql.connector.Error as err:
#         print(f"Error deleting recipient selections: {err}")
#         conn.rollback()
#         return jsonify({"error": "Failed to delete recipient selections", "details": str(err)}), 500
#     finally:
#         cursor.close()
#         conn.close()


if __name__ == '__main__':
    app.run(port=os.getenv("BACKEND_PORT", 5005), debug=True)
